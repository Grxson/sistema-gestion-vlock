import ApiService from '../api.js';

/**
 * Servicio para gesti√≥n de n√≥minas
 * Maneja todas las operaciones CRUD relacionadas con n√≥minas
 */
export class NominaService {
  static cache = new Map();
  static cacheTimeout = 5 * 60 * 1000; // 5 minutos

  /**
   * Obtiene todas las n√≥minas con filtros avanzados
   * @param {Object} filtros - Filtros de b√∫squeda
   * @returns {Promise<Object>} Respuesta con n√≥minas y metadatos
   */
  static async getAll(filtros = {}) {
    const cacheKey = `nominas_${JSON.stringify(filtros)}`;
    
    if (this.cache.has(cacheKey)) {
      const { data, timestamp } = this.cache.get(cacheKey);
      if (Date.now() - timestamp < this.cacheTimeout) {
        return data;
      }
    }

    try {
      const params = new URLSearchParams();
      
      // Filtros b√°sicos
      if (filtros.empleado_id) params.append('empleado_id', filtros.empleado_id);
      if (filtros.proyecto_id) params.append('proyecto_id', filtros.proyecto_id);
      if (filtros.estado) params.append('estado', filtros.estado);
      if (filtros.periodo) params.append('periodo', filtros.periodo);
      if (filtros.semana) params.append('semana', filtros.semana);
      
      // Filtros de fechas
      if (filtros.fecha_desde) params.append('fecha_desde', filtros.fecha_desde);
      if (filtros.fecha_hasta) params.append('fecha_hasta', filtros.fecha_hasta);
      
      // Filtros financieros
      if (filtros.monto_minimo) params.append('monto_minimo', filtros.monto_minimo);
      if (filtros.monto_maximo) params.append('monto_maximo', filtros.monto_maximo);
      
      // Paginaci√≥n y ordenamiento
      if (filtros.pagina) params.append('pagina', filtros.pagina);
      if (filtros.limite) params.append('limite', filtros.limite);
      if (filtros.orden) params.append('orden', filtros.orden);

      const response = await ApiService.get(`/nomina?${params.toString()}`);
      
      const result = {
        success: true,
        data: response.nominas || response.data || [],
        pagination: response.pagination || {},
        total: response.pagination?.total || (response.nominas || response.data || []).length
      };

      // Guardar en cach√©
      this.cache.set(cacheKey, {
        data: result,
        timestamp: Date.now()
      });

      return result;
    } catch (error) {
      console.error('Error fetching nominas:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Obtiene n√≥mina por ID con detalles completos
   * @param {number} id - ID de la n√≥mina
   * @param {boolean} includeDetails - Si incluir detalles
   * @returns {Promise<Object>} N√≥mina encontrada
   */
  static async getById(id, includeDetails = true) {
    try {
      const params = includeDetails ? '?include=empleado,semana,proyecto,pagos' : '';
      const response = await ApiService.get(`/nomina/${id}${params}`);
      
      return {
        success: true,
        data: response.nomina || response.data
      };
    } catch (error) {
      console.error('Error fetching nomina by ID:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Procesa una nueva n√≥mina
   * @param {Object} nominaData - Datos de la n√≥mina
   * @returns {Promise<Object>} Resultado del procesamiento
   */
  static async procesarNomina(nominaData) {
    try {
      console.log('üöÄ [NOMINA_SERVICE] Iniciando procesamiento de n√≥mina');
      console.log('üöÄ [NOMINA_SERVICE] Datos recibidos:', nominaData);
      
      // Validar datos requeridos
      const camposRequeridos = ['id_empleado', 'id_semana', 'id_proyecto', 'dias_laborados', 'pago_por_dia'];
      const camposFaltantes = camposRequeridos.filter(campo => !nominaData[campo]);
      
      console.log('üîç [NOMINA_SERVICE] Campos requeridos:', camposRequeridos);
      console.log('üîç [NOMINA_SERVICE] Campos faltantes:', camposFaltantes);
      
      if (camposFaltantes.length > 0) {
        console.error('‚ùå [NOMINA_SERVICE] Campos faltantes:', camposFaltantes);
        throw new Error(`Campos requeridos faltantes: ${camposFaltantes.join(', ')}`);
      }

      console.log('‚úÖ [NOMINA_SERVICE] Validaci√≥n exitosa, enviando a API...');
      const response = await ApiService.post('/nomina', nominaData);
      console.log('‚úÖ [NOMINA_SERVICE] Respuesta de API:', response);
      
      // Limpiar cach√©
      this.clearCache();
      
      const result = {
        success: true,
        data: response, // Mantener la estructura completa de la respuesta
        message: response.message || 'N√≥mina procesada exitosamente'
      };
      
      console.log('‚úÖ [NOMINA_SERVICE] Resultado final:', result);
      return result;
    } catch (error) {
      console.error('Error processing nomina:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Actualiza una n√≥mina existente
   * @param {number} id - ID de la n√≥mina
   * @param {Object} updateData - Datos a actualizar
   * @returns {Promise<Object>} Resultado de la actualizaci√≥n
   */
  static async update(id, updateData) {
    try {
      const response = await ApiService.put(`/nomina/${id}`, updateData);
      
      // Limpiar cach√©
      this.clearCache();
      
      return {
        success: true,
        data: response.data || response,
        message: response.message || 'N√≥mina actualizada exitosamente'
      };
    } catch (error) {
      console.error('Error updating nomina:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Cancela una n√≥mina
   * @param {number} id - ID de la n√≥mina
   * @param {string} motivo - Motivo de la cancelaci√≥n
   * @returns {Promise<Object>} Resultado de la cancelaci√≥n
   */
  static async cancelar(id, motivo = '') {
    try {
      const response = await ApiService.put(`/nomina/${id}/cancelar`, { motivo });
      
      // Limpiar cach√©
      this.clearCache();
      
      return {
        success: true,
        data: response.data || response,
        message: response.message || 'N√≥mina cancelada exitosamente'
      };
    } catch (error) {
      console.error('Error canceling nomina:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Aprueba una n√≥mina
   * @param {number} id - ID de la n√≥mina
   * @param {Object} datosAprobacion - Datos de la aprobaci√≥n
   * @returns {Promise<Object>} Resultado de la aprobaci√≥n
   */
  static async aprobar(id, datosAprobacion = {}) {
    try {
      const response = await ApiService.put(`/nomina/${id}/aprobar`, datosAprobacion);
      
      // Limpiar cach√©
      this.clearCache();
      
      return {
        success: true,
        data: response.data || response,
        message: response.message || 'N√≥mina aprobada exitosamente'
      };
    } catch (error) {
      console.error('Error approving nomina:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Marca una n√≥mina como pagada
   * @param {number} id - ID de la n√≥mina
   * @param {Object} datosPago - Datos del pago
   * @returns {Promise<Object>} Resultado del pago
   */
  static async marcarComoPagada(id, datosPago = {}) {
    try {
      const response = await ApiService.put(`/nomina/${id}/pagar`, datosPago);
      
      // Limpiar cach√©
      this.clearCache();
      
      return {
        success: true,
        data: response.data || response,
        message: response.message || 'N√≥mina marcada como pagada'
      };
    } catch (error) {
      console.error('Error marking nomina as paid:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Genera recibo PDF de una n√≥mina
   * @param {number} id - ID de la n√≥mina
   * @returns {Promise<Blob>} Archivo PDF
   */
  static async generarReciboPDF(id) {
    try {
      console.log('üìÑ [NominaService] Generando PDF para n√≥mina ID:', id);
      
      const response = await ApiService.get(`/nomina/${id}/recibo`, {
        responseType: 'blob',
        headers: {
          'Accept': 'application/pdf'
        }
      });

      console.log('üìÑ [NominaService] Respuesta recibida:', response);
      console.log('üìÑ [NominaService] Tipo de respuesta:', typeof response);
      console.log('üìÑ [NominaService] Es Blob:', response instanceof Blob);
      console.log('üìÑ [NominaService] Constructor:', response?.constructor?.name);
      console.log('üìÑ [NominaService] Tama√±o:', response?.size || 'N/A');
      console.log('üìÑ [NominaService] Tipo MIME:', response?.type || 'N/A');
      
      return response;
    } catch (error) {
      console.error('‚ùå [NominaService] Error generating PDF:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Obtiene n√≥minas por per√≠odo
   * @param {string} periodo - Per√≠odo en formato YYYY-MM
   * @returns {Promise<Object>} N√≥minas del per√≠odo
   */
  static async getNominasPeriodo(periodo) {
    return this.getAll({ periodo });
  }

  /**
   * Obtiene n√≥minas del per√≠odo actual
   * @returns {Promise<Object>} N√≥minas del per√≠odo actual
   */
  static async getNominasPeriodoActual() {
    const ahora = new Date();
    const periodo = `${ahora.getFullYear()}-${String(ahora.getMonth() + 1).padStart(2, '0')}`;
    return this.getNominasPeriodo(periodo);
  }

  /**
   * Obtiene estad√≠sticas de n√≥minas
   * @param {Object} filtros - Filtros para las estad√≠sticas
   * @returns {Promise<Object>} Estad√≠sticas
   */
  static async getEstadisticas(filtros = {}) {
    try {
      const response = await ApiService.get('/nomina/estadisticas', { params: filtros });
      return {
        success: true,
        data: response.data || response
      };
    } catch (error) {
      console.error('Error fetching nomina statistics:', error);
      throw this.handleError(error);
    }
  }

  /**
   * Limpia el cach√©
   */
  static clearCache() {
    this.cache.clear();
  }

  /**
   * Maneja errores de manera consistente
   * @param {Error} error - Error capturado
   * @returns {Error} Error formateado
   */
  static handleError(error) {
    console.error('NominaService Error:', error);
    
    if (error.response) {
      // Error de respuesta del servidor
      const message = error.response.data?.message || error.response.statusText || 'Error del servidor';
      return new Error(`Error ${error.response.status}: ${message}`);
    } else if (error.request) {
      // Error de red
      return new Error('Error de conexi√≥n. Verifica tu conexi√≥n a internet.');
    } else {
      // Error de configuraci√≥n o validaci√≥n
      return new Error(error.message || 'Error inesperado');
    }
  }
}
